
<!DOCTYPE html>

<head>
    <meta charset="UTF-8">
    <title>Fractals</title>
</head>
<body style="margin: 0; padding: 0; overflow: hidden;">
    <canvas id="canvas">
        Your browser doesn't appear to support the HTML5 canvas element
    </canvas>

    <script type="shader" id="vertex-shader">
        attribute vec2 vertexPosition;
		
        void main(){
            gl_Position = vec4(vertexPosition, 0.0, 1);
        }
    </script>

    <script type="shader" id="fragment-shader">
        precision highp float;

		uniform vec2 u_resolution;
		uniform highp vec2 a, b, start;
		uniform float h;

        void main(){
			vec2 c = (gl_FragCoord.xy + a) * b;
			vec2 z = c;
			//z *= h;
			float tmp = 0.0, J, sinJ, sinJ2, sinJ3, sinJ4;
			for (float i = 0.0; i < 360.0; i += 8.0) {
				if (z.x > 2.0) z.x = 3.0;
				else if (z.y > 2.0) z.y = 3.0;
				else if (z.x < -2.0) z.x = -3.0;
				else if (z.y < -2.0) z.y = -3.0;
				else {
					tmp = z.x * z.x - z.y * z.y + start.x;
					z.y = abs(2.0 * z.x * z.y) + start.y;
					z.x = tmp;
					J = i;
				}
			}
			
			if (z.x * z.x + z.y * z.y > 4.0) {
				sinJ = sin(J * 0.01745);
				sinJ2 = sinJ * sinJ;
				sinJ3 = sinJ2 * sinJ;
				sinJ4 = sinJ3 * sinJ;
				
				gl_FragColor = vec4(
					abs(2.645 * sinJ4 - 0.809 * sinJ3 - 2.739 * sinJ2 + 0.715 * sinJ + 1.0),
					abs(-2.086 * sinJ4 + 1.808 * sinJ3 + 2.5755 * sinJ2 - 1.396 * sinJ + 0.024),
					abs(1.287 * sinJ4 - 1.37 * sinJ3 - 2.166 * sinJ2 + 1.265 * sinJ + 1.0),
					1.0);
			} else {
				gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
			}
        }
    </script>

    <script>
        function StartWebGL() {
            var vertexShaderText = document.getElementById('vertex-shader').text,
                fragmentShaderText = document.getElementById('fragment-shader').text,
                canvas = document.getElementById('canvas'),
                gl = canvas.getContext('webgl');
                
            if (!gl) {
                alert('Your browser does not support WebGL');
                return;
            }
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            alert(canvas.width);
            gl.viewport(0, 0, canvas.width, canvas.height);

            var vertexShader = gl.createShader(gl.VERTEX_SHADER);
                fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            
            gl.shaderSource(vertexShader, vertexShaderText);
            gl.shaderSource(fragmentShader, fragmentShaderText);
            
            gl.compileShader(vertexShader);
            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                alert('Error compiling vertex shader!');
				console.error(gl.getShaderInfoLog(vertexShader));
                return;
            }

            gl.compileShader(fragmentShader);
            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                alert('Error compiling fragment shader!');
				console.error(gl.getShaderInfoLog(fragmentShader));
                return;
            }
            
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            gl.validateProgram(program);
            
            if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {
                alert('Error validating program');
                return;
            }

            var vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            
            var vertexArray = [
                -1.0,  -1.0,
                -1.0, 1.0,
                 1.0, 1.0,
                 1.0,  -1.0,
            ];
            
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexArray), gl.STATIC_DRAW);
            var positionAttribLocation = gl.getAttribLocation(program, 'vertexPosition');
            gl.vertexAttribPointer(
                positionAttribLocation,
                2,
                gl.FLOAT,
                gl.FALSE,
                0,
                0
            );
            gl.enableVertexAttribArray(positionAttribLocation);

			var a = gl.getUniformLocation(program, "a"),
				b = gl.getUniformLocation(program, "b"),
				h = gl.getUniformLocation(program, "h"),
				start = gl.getUniformLocation(program, "start");

            gl.useProgram(program);
			
			var x1 = -3 * canvas.width / canvas.height, 
				y1 = -3, 
				x2 = 3 * canvas.width / canvas.height, 
				y2 = 3, 
				stepX = (x2 - x1) / canvas.width, 
				stepY = (y2 - y1) / canvas.height,
				height = 1,
				timeOut = false;
			
			var timer = setInterval(function() {
				timeOut = true;
			}, 33);
				
			canvas.addEventListener('mousemove', function(event) {
				if (timeOut) {
					timeOut = !timeOut;
					gl.clearColor(0.0, 0.0, 0.0, 1.0);
					gl.clear(gl.COLOR_BUFFER_BIT);
					
					gl.uniform2fv(start, [x1 + stepX * event.clientX, y1 + stepY * event.clientY]);
					gl.uniform2fv(a, [x1 / stepX, y1 / stepY]);
					gl.uniform2fv(b, [stepX, stepY]);
					gl.uniform1f(h, height);
					
					gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
				}
			});
			/*
			canvas.onclick = function(event) {
				x1 = x1 + stepX * (event.clientX - window.innerWidth / 4);
				y1 = y1 + stepY * (window.innerHeight - event.clientY - window.innerHeight / 4);
				stepX /= 2;
				stepY /= 2;
				x2 = x1 + event.clientX * stepX;
				y2 = y1 + event.clientY * stepY;
			}
			*/
		}
		

        document.addEventListener('DOMContentLoaded', function() {
            StartWebGL();
        });

    </script>
</body>
